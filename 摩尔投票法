普通的摩尔投票法

首先我们了解下什么是摩尔投票法:其基于一个事实: 当数组中存在某个数个数大于数组长度的1/2
时，我们可以使用使用摩尔投票法找出这个数。

算法：设置一个候选人和一个计数器count。遍历数组，每次遇到和候选人一样的值则count + 1，否
则count - 1.当count == 0 时替换候选人。最后剩下的就是我们所求的众数。

那么为什么能这样求呢？首先我们可以把数组中的数分为两类：众数和其他数。
算法中遇到和候选人不一样的值进行count - 1时其实可以看成一次互拼。而我们必须要保证这个互拼只有以下2种情况：
1.众数和其他数互拼，两者同时消耗1.
2.其他数和其他数互拼，其他数消耗2.
如果我们想要最后剩下的都是众数，那么按照对众数最不利的情况是所有的互拼都是情况1.而由于众数的个数大于2/n，所以最不利的情况最后留下来的也是众数。
而在算法中我们保证互拼只有以上2种情况的方法就是：我们遇到相同的候选人则count+1，这样可以避免众数和众数互拼(因为众数肯定是相等的，所以相同的时候count++就避免了众数和众数互拼)
题目：169.多数元素

我们回到本题：

本题是求个数大于长度1/3的所有数。假设数组长度为n,那么我们稍微思考可以得出结论个数超过3/n的数不会超过2个。
算法思想是设置两个候选人以及两个计数器。遍历到和候选人相同时则对应计数器+1，如果和两个候选人都不相同则两个计数器都-1，当一个计数器为0时，更换对应的候选人。遍历完剩下的则是2个众数。
同上面分析，为何我们可以这么做？此题我们可以分成三类数： 众数一、众数二和其他数。
和上面思想一样，遍历时遇到和两个候选人都不一样的值，则是一次互拼，我们必须要保证这两种情况：
1.众数一，众数二，其他数 三者拼，都消耗1。
2.某众数，和2个其他数 三者拼，某众数消耗1，其他数消耗2.
和上述同样的分析方法可以得出最后剩下的一定是2个众数。




作者：clearboy
链接：https://leetcode-cn.com/problems/majority-element-ii/solution/mo-er-tou-piao-fa-jin-jie-ban-by-clearboy/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
